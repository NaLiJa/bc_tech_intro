"""
Implements a simple blockchain data structure.
"""

from hashlib import sha256
import time
import logging
import re
from functools import reduce
from datetime import datetime


def flatten(list_of_lists):
    return reduce(lambda x, y: x + y, list_of_lists)


logger = logging.getLogger(__file__)

NO_PRECEDING_BLOCKS = ""
SHA_256_matcher = re.compile('')


class CorruptedHeaderError(ValueError):
    """
    Exception raised when a transaction in a block is detected
    as being corrupted.
    """

    def __init__(self, message):
        super(CorruptedHeaderError, self).__init__(message)


class InvalidMiningSolutionError(ValueError):
    """
    Exception raised when a string is not a valid solution to
    the cryptographic puzzle.
    """

    def __init__(self, message):
        super(InvalidMiningSolutionError, self).__init__(message)


class CorruptedPreviousHeaderError(ValueError):
    """
    Exception raised when the previous header is detected as being
    corrupt.
    """

    def __init__(self, message):
        super(CorruptedPreviousHeaderError, self).__init__(message)


def solve_super_expensive_mining_puzzle(time_to_waste=86400):
    """
    A stand-in function for the "mining" operation, which
    essentially solves a cryptographic puzzle that takes a
    very long time to solve but is very easy to verify.

    Parameters
    ----------

    time_to_waste: int (default = 86400)
        A dummy parameter indicating how expensive this operation
        should be, which is how long it should sleep in seconds.

    Returns
    -------
    str:
        a dummy puzzle solution
    """
    time.sleep(time_to_waste)
    return "a solved puzzle " + \
           sha256(str(time.time()).encode('utf-8')).hexdigest()


def super_expensive_mining_puzzle_verifier(mining_puzzle_solution):
    """
    A stand-in function for verifying that the argument passed
    is actually a valid solution for some cryptographic puzzle.

    Parameters
    ---------

    mining_puzzle_solution: str
        The dummy solution to verify as true or false.

    Returns
    -------

    bool:
        The dummy solution verifier.
        True if the solution could possibly have been generated by
        the stand-in function and False otherwise.
    """
    start_str = "a solved puzzle "
    return mining_puzzle_solution.startswith(start_str) and \
           re.match('^[0-9a-fA-F]{64}$',
                    mining_puzzle_solution[len(start_str):], ) is not None


class BlockBasic(object):
    """
    Class implementing a basic block in the basic blockchain
    data structure implemented below.

    Parameters
    ----------

    prev_block_header: str
        Hash of the previous block in the chain.

    transaction_list: str list
        A list of transactions to add to the block.

    mining_puzzle_solution: str
        Solution to solved puzzle
    """
    def __init__(self, prev_block_header, transaction_list, nonce):
        self.transaction_list = transaction_list
        self.prev_block_header_checked = \
            prev_block_header if prev_block_header is not None \
                else NO_PRECEDING_BLOCKS
        self.nonce = nonce
        self.timestamp = str(datetime.now())

        intermediate_header = sha256(
            (self.prev_block_header_checked +
             flatten(self.transaction_list) +
             self.timestamp).encode('utf-8')
        ).hexdigest()

        if not mining_puzzle_verifier(intermediate_header + self.nonce):
            raise InvalidMiningSolutionError("The nonce supplied does not solve the mining puzzle.")

        self.block_header = sha256(
            intermediate_header +
            self.nonce +
            self.prev_block_header_checked +
            flatten(self.transaction_list) +
            self.timestamp).encode('utf-8')
        ).hexdigest()


    def get_transaction(self):
        """
        Returns the transaction associated with this block after
        making sure it was not corrupted.

        Returns
        -------
        str:
            The transaction stored in this block
        """
        calculated_header = sha256(
            (self.prev_block_header_checked +
             self.transaction_list +
             self.mining_puzzle_solution).encode('utf-8')
        ).hexdigest()

        if self.block_header != calculated_header:
            raise CorruptedHeaderError(
                f"Header {self.block_header[0:10]} is corrupted - something in the chain or "
                f"block was modified.")

        return self.transaction_list


class BlockChainBasic(object):
    """
    Class implementing a basic blockchain data structure to illustrate the core ideas .
    """

    def __init__(self):
        self.chain = {}
        self.chain_head = None

    def add_block(self, new_block):
        """
        Add a block to the chain.

        Parameters
        ----------

        new_block: BlockBasic
            The block to add to the chain
        """
        if not super_expensive_mining_puzzle_verifier(new_block.mining_puzzle_solution):
            raise InvalidMiningSolutionError(
                f"Attempting to add block {new_block.block_header[0:10]} "
                f"with invalid mining puzzle solution."
            )

        calculated_header = sha256(
            (self.chain_head +
             flatten(new_block.transaction_list) +
             new_block.mining_puzzle_solution).encode('utf-8')
        ).hexdigest()

        if calculated_header != new_block.block_header:
            raise CorruptedHeaderError(f"New block header {new_block.block_header[0:10]} is invalid.")
        self.chain_head = new_block.block_header
        self.chain[self.chain_head] = new_block

        return True

    def traverse_chain(self, num_blocks, process_transaction=lambda x: []):
        """
        Traverse the chain, and carry out the given processing task on each transaction.

        Parameters
        ----------

        num_blocks: int
            The number of blocks in the chain to traverse.

        process_transaction: function or lambda
            The function to run to process each transation.

        Returns
        -------

        list:
            List of processed transactions.
        """
        if cur_block is None:
            return []

        cur_block = self.chain[self.chain_head]
        processed_trans = []
        cnt = 0
        while cnt < num_blocks and cur_block.prev_block_header is not None:
            processed_trans.append(process_transaction(cnt, cur_block, cur_block.get_transaction()))
            try:
                cur_block = self.chain[cur_block.prev_block_header]
            except KeyError as k:
                raise CorruptedPreviousHeaderError(
                    f"Invalid blockchain data structure - "
                    f"header {cur_block.prev_block_header[10]}"
                    f"preceding block {cur_block.block_header[10]} not found.")

        return processed_trans

    def transactions_from_first_k_blocks(self, num_trans):
        """
        Returns the first min(num_blocks, size-of-chain) transactions

        Parameters
        ----------

        num_trans: int
            Number of transactions to return.

        Returns
        -------

        list str:
            List of transactions.
        """
        return self.traverse_chain(num_trans, lambda x: x)

    def transactions_from_kth_block(self, block_num):
        """
        Returns the kth block where k = min(num_blocks, size-of-chain)

        Parameters
        ----------

        block_num: int
            The index of the block to return.

        Returns
        -------

        str:
            The transaction.
        """

        def save_if_last(cnt, cur_block, transaction):
            return [transaction] if cnt == block_num or cur_block.prev_block_header \
                else NO_PRECEDING_BLOCKS

        return self.traverse_chain(block_num, save_if_last)[0]
